import { exec } from 'child_process';
import { promisify } from 'util';
import type { IStorage } from './storage';

const execAsync = promisify(exec);

// npm audit JSON output types
interface NpmAuditVulnerability {
  severity: 'info' | 'low' | 'moderate' | 'high' | 'critical';
  via: string | Array<{
    source?: string;
    name?: string;
    title?: string;
    url?: string;
    severity?: string;
  }>;
  effects?: string[];
  range?: string;
  nodes?: string[];
  fixAvailable?: boolean | {
    name: string;
    version: string;
    isSemVerMajor: boolean;
  };
}

interface NpmAuditResult {
  auditReportVersion: number;
  vulnerabilities: Record<string, NpmAuditVulnerability>;
  metadata: {
    vulnerabilities: {
      info: number;
      low: number;
      moderate: number;
      high: number;
      critical: number;
      total: number;
    };
    dependencies: {
      prod: number;
      dev: number;
      optional: number;
      peer: number;
      peerOptional: number;
      total: number;
    };
  };
}

/**
 * Run npm audit and store results in database
 * NIST 800-53 RA-5: Vulnerability Scanning
 * NIST 800-53 SI-2: Flaw Remediation
 */
export async function runVulnerabilityScan(storage: IStorage): Promise<void> {
  // Create initial scan record
  const scan = await storage.createVulnerabilityScan({
    status: 'running',
    completedAt: null,
    totalVulnerabilities: 0,
    infoCount: 0,
    lowCount: 0,
    moderateCount: 0,
    highCount: 0,
    criticalCount: 0,
    scanData: null,
    errorMessage: null,
  });

  try {
    // Run npm audit with JSON output
    // Using --audit-level=none to prevent non-zero exit codes that don't indicate actual errors
    const { stdout } = await execAsync('npm audit --json --audit-level=none', {
      cwd: process.cwd(),
      maxBuffer: 10 * 1024 * 1024, // 10MB buffer for large audit results
    });

    // Parse audit results
    const auditResult: NpmAuditResult = JSON.parse(stdout);
    const metadata = auditResult.metadata.vulnerabilities;

    // Update scan with results
    await storage.updateVulnerabilityScan(scan.id, {
      status: 'completed',
      completedAt: new Date(),
      totalVulnerabilities: metadata.total,
      infoCount: metadata.info,
      lowCount: metadata.low,
      moderateCount: metadata.moderate,
      highCount: metadata.high,
      criticalCount: metadata.critical,
      scanData: auditResult,
      errorMessage: null,
    });

    // Log critical and high vulnerabilities as security events
    if (metadata.critical > 0 || metadata.high > 0) {
      const criticalPackages: string[] = [];
      
      for (const [packageName, vuln] of Object.entries(auditResult.vulnerabilities)) {
        if (vuln.severity === 'critical' || vuln.severity === 'high') {
          criticalPackages.push(packageName);
        }
      }

      await storage.logSecurityEvent({
        eventType: 'suspicious_activity',
        severity: metadata.critical > 0 ? 'critical' : 'warning',
        userId: null,
        email: 'system',
        ipAddress: 'system',
        userAgent: 'vulnerability-scanner',
        organizationId: null,
        eventData: {
          type: 'vulnerability_scan_critical',
          totalVulnerabilities: metadata.total,
          criticalCount: metadata.critical,
          highCount: metadata.high,
          affectedPackages: criticalPackages.slice(0, 10), // Limit to first 10 for brevity
          message: `Dependency scan found ${metadata.critical} critical and ${metadata.high} high severity vulnerabilities`,
        },
      });
    }

    console.log(`[Vulnerability Scan] Completed: ${metadata.total} vulnerabilities found (${metadata.critical} critical, ${metadata.high} high, ${metadata.moderate} moderate, ${metadata.low} low, ${metadata.info} info)`);
  } catch (error) {
    // Update scan with error
    await storage.updateVulnerabilityScan(scan.id, {
      status: 'failed',
      completedAt: new Date(),
      errorMessage: error instanceof Error ? error.message : 'Unknown error during vulnerability scan',
    });

    // Log scan failure as security event
    await storage.logSecurityEvent({
      eventType: 'suspicious_activity',
      severity: 'warning',
      userId: null,
      email: 'system',
      ipAddress: 'system',
      userAgent: 'vulnerability-scanner',
      organizationId: null,
      eventData: {
        type: 'vulnerability_scan_failed',
        error: error instanceof Error ? error.message : 'Unknown error',
        message: 'Automated vulnerability scan failed',
      },
    });

    console.error('[Vulnerability Scan] Failed:', error);
    throw error;
  }
}

/**
 * Get a summary of the latest vulnerability scan
 */
export async function getLatestVulnerabilitySummary(storage: IStorage): Promise<{
  lastScan: Date | null;
  status: string;
  totalVulnerabilities: number;
  criticalCount: number;
  highCount: number;
  moderateCount: number;
  lowCount: number;
  infoCount: number;
}> {
  const latest = await storage.getLatestVulnerabilityScan();

  if (!latest) {
    return {
      lastScan: null,
      status: 'never_run',
      totalVulnerabilities: 0,
      criticalCount: 0,
      highCount: 0,
      moderateCount: 0,
      lowCount: 0,
      infoCount: 0,
    };
  }

  return {
    lastScan: latest.startedAt,
    status: latest.status,
    totalVulnerabilities: latest.totalVulnerabilities || 0,
    criticalCount: latest.criticalCount || 0,
    highCount: latest.highCount || 0,
    moderateCount: latest.moderateCount || 0,
    lowCount: latest.lowCount || 0,
    infoCount: latest.infoCount || 0,
  };
}
